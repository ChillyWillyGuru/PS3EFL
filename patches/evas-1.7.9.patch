diff -burN evas-1.7.9/configure.ac evas-1.7.9-PS3/configure.ac
--- evas-1.7.9/configure.ac	2013-10-18 12:58:34.000000000 -0400
+++ evas-1.7.9-PS3/configure.ac	2014-07-03 17:58:24.300177571 -0400
@@ -110,6 +110,7 @@
 want_evas_engine_fb="no"
 want_evas_engine_directfb="no"
 want_evas_engine_psl1ght="no"
+want_evas_engine_gl_psl1ght="no"
 want_evas_engine_wayland_shm="no"
 want_evas_engine_wayland_egl="no"
 
@@ -168,6 +169,7 @@
 case "$host_vendor" in
   ps3*)
       want_evas_engine_psl1ght="static"
+      want_evas_engine_gl_psl1ght="static"
       ;;
 esac
 
@@ -751,6 +753,8 @@
 
 EVAS_CHECK_ENGINE([psl1ght], [${want_evas_engine_psl1ght}], [no], [PSL1GHT])
 
+EVAS_CHECK_ENGINE([gl-psl1ght], [${want_evas_engine_gl_psl1ght}], [no], [GL_PSL1GHT])
+
 EVAS_CHECK_ENGINE([gl-sdl], [${want_evas_engine_gl_sdl}], [no], [OpenGL SDL])
 
 EVAS_CHECK_ENGINE([gl-cocoa], [${want_evas_engine_gl_cocoa}], [no], [OpenGL Cocoa])
@@ -931,7 +935,8 @@
    || test "x$have_evas_engine_gl_xcb" = "xstatic" \
    || test "x$have_evas_engine_gl_sdl" = "xstatic" \
    || test "x$have_evas_engine_gl_cocoa" = "xstatic" \
-   || test "x$have_evas_engine_wayland_egl" = "xstatic"; then
+   || test "x$have_evas_engine_wayland_egl" = "xstatic" \
+   || test "x$have_evas_engine_gl_psl1ght" = "xstatic"; then
    have_evas_engine_gl_common="yes"
    have_static_evas_engine_gl_common="yes"
 fi
@@ -1825,6 +1830,7 @@
 evas-software-16-wince.pc
 evas-software-sdl.pc
 evas-psl1ght.pc
+evas-gl-psl1ght.pc
 evas-wayland-shm.pc
 evas-wayland-egl.pc
 evas.pc
@@ -1877,6 +1883,7 @@
 src/modules/engines/gl_x11/Makefile
 src/modules/engines/gl_sdl/Makefile
 src/modules/engines/gl_cocoa/Makefile
+src/modules/engines/gl_psl1ght/Makefile
 src/modules/engines/psl1ght/Makefile
 src/modules/engines/software_8/Makefile
 src/modules/engines/software_8_x11/Makefile
@@ -1969,6 +1976,7 @@
 echo "  Software Framebuffer.......: $have_evas_engine_fb"
 echo "  DirectFB...................: $have_evas_engine_directfb"
 echo "  PSL1GHT....................: $have_evas_engine_psl1ght"
+echo "  RSXGL PSL1GHT..............: $have_evas_engine_gl_psl1ght"
 echo "  Software 8bit grayscale....: $have_evas_engine_software_8"
 # FIXME: kill software 16bit
 echo "  Software 16bit ............: $have_evas_engine_software_16"
diff -burN evas-1.7.9/evas-gl-psl1ght.pc.in evas-1.7.9-PS3/evas-gl-psl1ght.pc.in
--- evas-1.7.9/evas-gl-psl1ght.pc.in	1969-12-31 19:00:00.000000000 -0500
+++ evas-1.7.9-PS3/evas-gl-psl1ght.pc.in	2014-07-03 17:58:24.301177571 -0400
@@ -0,0 +1,3 @@
+Name: evas-gl-psl1ght
+Description: Evas RSXGL PSL1GHT engine
+Version: @VERSION@
\ No newline at end of file
diff -burN evas-1.7.9/evas.pc.in evas-1.7.9-PS3/evas.pc.in
--- evas-1.7.9/evas.pc.in	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/evas.pc.in	2014-07-03 17:59:06.752179080 -0400
@@ -10,5 +10,5 @@
 @pkgconfig_requires_private@: @requirement_evas@
 Version: @VERSION@
 Libs: -L${libdir} -levas @EINA_LIBS@ @shm_open_libs@
-Libs.private: @EFL_FNMATCH_LIBS@ @pthread_libs@ @shm_open_libs@
+Libs.private: @EFL_FNMATCH_LIBS@ @pthread_libs@ @shm_open_libs@ @evas_engine_gl_psl1ght_libs@
 Cflags: -I${includedir}/evas-@VMAJ@
diff -burN evas-1.7.9/m4/evas_check_engine.m4 evas-1.7.9-PS3/m4/evas_check_engine.m4
--- evas-1.7.9/m4/evas_check_engine.m4	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/m4/evas_check_engine.m4	2014-07-03 18:05:17.480192257 -0400
@@ -612,6 +612,10 @@
    fi
 fi
 
+if test "x${have_dep}" = "xyes" ; then
+   PKG_CHECK_MODULES([GL_EET], [eet >= 1.6.99], [have_dep="yes"], [have_dep="no"])
+fi
+
 AC_SUBST([evas_engine_$1_cflags])
 AC_SUBST([evas_engine_$1_libs])
 
@@ -797,6 +801,45 @@
 
 AC_SUBST([evas_engine_$1_cflags])
 AC_SUBST([evas_engine_$1_libs])
+
+if test "x${have_dep}" = "xyes" ; then
+  m4_default([$4], [:])
+else
+  m4_default([$5], [:])
+fi
+
+])
+
+dnl use: EVAS_CHECK_ENGINE_DEP_PSL1GHT(engine, simple, want_static[, ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])
+
+AC_DEFUN([EVAS_CHECK_ENGINE_DEP_GL_PSL1GHT],
+[
+
+have_dep="no"
+evas_engine_[]$1[]_cflags=""
+evas_engine_[]$1[]_libs=""
+
+AC_CHECK_HEADER([rsx/rsx.h], [have_dep="yes"])
+
+AC_CHECK_HEADER([GL3/gl3.h],
+   [have_dep="yes"],
+   [have_dep="no"],
+   [
+#include <GL3/gl3.h>
+#include <GL3/gl3ext.h>
+#include <EGL/egl.h>
+   ])
+
+if test "x${have_dep}" = "xyes" ; then
+   PKG_CHECK_MODULES([GL_EET], [eet >= 1.7.9], [have_dep="yes"], [have_dep="no"])
+   if test "x${have_dep}" = "xyes" ; then
+      evas_engine_[]$1[]_libs="-lGL -lEGL -lstdc++ -lm"
+      evas_engine_gl_common_libs="-lGL -lEGL -lstdc++ -lm"
+   fi
+fi
+
+AC_SUBST([evas_engine_$1_cflags])
+AC_SUBST([evas_engine_$1_libs])
 
 if test "x${have_dep}" = "xyes" ; then
   m4_default([$4], [:])
diff -burN evas-1.7.9/Makefile.am evas-1.7.9-PS3/Makefile.am
--- evas-1.7.9/Makefile.am	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/Makefile.am	2014-07-03 17:58:24.302177571 -0400
@@ -43,6 +43,7 @@
 evas-direct3d.pc.in \
 evas-software-16-wince.pc.in \
 evas-psl1ght.pc.in \
+evas-gl-psl1ght.pc.in \
 evas-wayland-shm.pc.in \
 evas-wayland-egl.pc.in \
 evas.spec.in \
@@ -124,6 +125,10 @@
 pkgconfig_DATA += evas-psl1ght.pc
 endif
 
+if BUILD_ENGINE_GL_PSL1GHT
+pkgconfig_DATA += evas-gl-psl1ght.pc
+endif
+
 if BUILD_ENGINE_WAYLAND_SHM
 pkgconfig_DATA += evas-wayland-shm.pc
 endif
diff -burN evas-1.7.9/src/lib/file/evas_module.c evas-1.7.9-PS3/src/lib/file/evas_module.c
--- evas-1.7.9/src/lib/file/evas_module.c	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/lib/file/evas_module.c	2014-07-03 18:07:41.160197364 -0400
@@ -99,6 +99,7 @@
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, gl_x11);
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, gl_sdl);
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, psl1ght);
+EVAS_EINA_STATIC_MODULE_DEFINE(engine, gl_psl1ght);
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, software_16);
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, software_16_sdl);
 EVAS_EINA_STATIC_MODULE_DEFINE(engine, software_16_wince);
@@ -155,6 +156,9 @@
 #ifdef EVAS_STATIC_BUILD_PSL1GHT
   EVAS_EINA_STATIC_MODULE_USE(engine, psl1ght),
 #endif
+#ifdef EVAS_STATIC_BUILD_GL_PSL1GHT
+  EVAS_EINA_STATIC_MODULE_USE(engine, gl_psl1ght),
+#endif
 #ifdef EVAS_STATIC_BUILD_SOFTWARE_16
   EVAS_EINA_STATIC_MODULE_USE(engine, software_16),
 #endif
diff -burN evas-1.7.9/src/lib/Makefile.am evas-1.7.9-PS3/src/lib/Makefile.am
--- evas-1.7.9/src/lib/Makefile.am	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/lib/Makefile.am	2014-07-03 17:58:24.302177571 -0400
@@ -48,6 +48,13 @@
 EVAS_STATIC_MODULE += ../modules/engines/psl1ght/libevas_engine_psl1ght.la
 EVAS_STATIC_LIBADD += @evas_engine_psl1ght_libs@
 endif
+if EVAS_STATIC_BUILD_GL_PSL1GHT
+SUBDIRS += \
+	../modules/engines/gl_common \
+	../modules/engines/gl_psl1ght/
+EVAS_STATIC_MODULE += ../modules/engines/gl_psl1ght/libevas_engine_gl_psl1ght.la
+EVAS_STATIC_LIBADD += @evas_engine_gl_common_libs@ @evas_engine_gl_psl1ght_libs@
+endif
 if EVAS_STATIC_BUILD_SOFTWARE_16
 SUBDIRS += ../modules/engines/software_16/
 EVAS_STATIC_MODULE += ../modules/engines/software_16/libevas_engine_software_16.la
diff -burN evas-1.7.9/src/modules/engines/gl_common/evas_gl_common.h evas-1.7.9-PS3/src/modules/engines/gl_common/evas_gl_common.h
--- evas-1.7.9/src/modules/engines/gl_common/evas_gl_common.h	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/modules/engines/gl_common/evas_gl_common.h	2014-07-03 19:05:04.954319768 -0400
@@ -19,6 +19,11 @@
 # include <OpenGL/gl.h>
 # include <OpenGL/glext.h>
 #else
+# ifdef BUILD_ENGINE_GL_PSL1GHT
+#  define GL3_PROTOTYPES
+#  include <GL3/gl3.h>
+#  include <GL3/gl3ext.h>
+# else
 # ifdef _EVAS_ENGINE_SDL_H
 #  if defined(GLES_VARIETY_S3C6410) || defined(GLES_VARIETY_SGX)
 #   include <SDL/SDL_opengles.h>
@@ -38,6 +43,7 @@
 #   include <GL/glext.h>
 #  endif
 # endif
+# endif
 #endif
 
 #ifndef GL_TEXTURE_RECTANGLE_NV
@@ -268,6 +274,9 @@
 #define RTYPE_IMASK 6
 #define RTYPE_YUY2  7
 #define RTYPE_NV12  8
+#define GL_USE_SERVER_BUFFERS
+#define ARRAY_BUFFER_USE 500
+#define ARRAY_BUFFER_USE_SHIFT 100
 
 struct _Evas_Engine_GL_Context
 {
@@ -330,6 +339,11 @@
          Eina_Bool use_texuv3 : 1;
          Eina_Bool use_texm : 1;
          Evas_GL_Image *im;
+#ifdef GL_USE_SERVER_BUFFERS
+         GLuint buffer;
+         int buffer_alloc;
+         int buffer_use;
+#endif
       } array;
    } pipe[MAX_PIPES];
 
diff -burN evas-1.7.9/src/modules/engines/gl_common/evas_gl_context.c evas-1.7.9-PS3/src/modules/engines/gl_common/evas_gl_context.c
--- evas-1.7.9/src/modules/engines/gl_common/evas_gl_context.c	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/modules/engines/gl_common/evas_gl_context.c	2014-07-03 19:32:42.533378683 -0400
@@ -3,7 +3,8 @@
 #ifdef HAVE_DLSYM
 # include <dlfcn.h>      /* dlopen,dlclose,etc */
 #else
-# error gl_common should not get compiled if dlsym is not found on the system!
+/* If we can't find the symbols, let's assume they don't exist */
+#define dlsym(...) NULL
 #endif
 
 #define PRG_INVALID 0xffffffff
@@ -55,6 +56,18 @@
    if (sym_done) return;
    sym_done = 1;
 
+#ifdef __lv2ppu__
+   glsym_glGenFramebuffers = glGenFramebuffers;
+   glsym_glBindFramebuffer = glBindFramebuffer;
+   glsym_glFramebufferTexture2D = glFramebufferTexture2D;
+   glsym_glDeleteFramebuffers = glDeleteFramebuffers;
+   glsym_glGetProgramBinary = NULL;
+   glsym_glProgramBinary = NULL;
+   glsym_glProgramParameteri = NULL;
+   glsym_glReleaseShaderCompiler = glReleaseShaderCompiler;
+   return;
+#endif
+
    /* FIXME: If using the SDL engine, we should use SDL_GL_GetProcAddress
     * instead of dlsym
     * if (!dst) dst = (typ)SDL_GL_GetProcAddress(sym)
@@ -498,7 +511,14 @@
    _evas_gl_common_context = gc;
 
    for (i = 0; i < MAX_PIPES; i++)
+     {
       gc->pipe[i].shader.render_op = EVAS_RENDER_BLEND;
+#ifdef GL_USE_SERVER_BUFFERS
+        glGenBuffers (1, &gc->pipe[i].array.buffer);
+        gc->pipe[i].array.buffer_alloc = 0;
+        gc->pipe[i].array.buffer_use = 0;
+#endif
+     }
 
    if (!shared)
      {
@@ -758,6 +778,11 @@
 
    if (gc->def_surface) evas_gl_common_image_free(gc->def_surface);
 
+#ifdef GL_USE_SERVER_BUFFERS
+   for (i = 0; i < MAX_PIPES; i++)
+      glDeleteBuffers (1, &gc->pipe[i].array.buffer);
+#endif
+
    if (gc->shared)
      {
         for (i = 0; i < gc->shared->info.tune.pipes.max; i++)
@@ -2537,16 +2562,60 @@
                                gc->pipe[i].shader.cw, gc->pipe[i].shader.ch);
                }
           }
-
-        glVertexAttribPointer(SHAD_VERTEX, 3, GL_SHORT, GL_FALSE, 0, gc->pipe[i].array.vertex);
+#ifdef GL_USE_SERVER_BUFFERS
+# define VERTEX_SIZE (gc->pipe[i].array.alloc * sizeof(GLshort) * 3)
+# define COLOR_SIZE (gc->pipe[i].array.alloc * sizeof(GLubyte) * 4)
+# define TEX_SIZE (gc->pipe[i].array.alloc * sizeof(GLfloat) * 2)
+# define VERTEX_POINTER 0
+# define COLOR_POINTER (VERTEX_POINTER + VERTEX_SIZE)
+# define TEXUV_POINTER (COLOR_POINTER + COLOR_SIZE)
+# define TEXUV2_POINTER (TEXUV_POINTER + TEX_SIZE)
+# define TEXUV3_POINTER (TEXUV2_POINTER + TEX_SIZE)
+# define TEXM_POINTER (TEXUV3_POINTER + TEX_SIZE)
+# define END_POINTER (TEXM_POINTER + TEX_SIZE)
+
+        glBindBuffer(GL_ARRAY_BUFFER, gc->pipe[i].array.buffer);
+
+        if (gc->pipe[i].array.buffer_alloc < END_POINTER ||
+            gc->pipe[i].array.buffer_use >= (ARRAY_BUFFER_USE + ARRAY_BUFFER_USE_SHIFT * i))
+          {
+             glBufferData(GL_ARRAY_BUFFER, END_POINTER, NULL, GL_STATIC_DRAW);
+             gc->pipe[i].array.buffer_alloc = END_POINTER;
+             gc->pipe[i].array.buffer_use = 0;
+          }
+        gc->pipe[i].array.buffer_use++;
+
+        void * x = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+        if (gc->pipe[i].array.use_vertex)
+          memcpy (x + VERTEX_POINTER, gc->pipe[i].array.vertex, VERTEX_SIZE);
+        if (gc->pipe[i].array.use_color)
+          memcpy (x + COLOR_POINTER, gc->pipe[i].array.color, COLOR_SIZE);
+        if (gc->pipe[i].array.use_texuv)
+          memcpy (x + TEXUV_POINTER, gc->pipe[i].array.texuv, TEX_SIZE);
+        if (gc->pipe[i].array.use_texuv2)
+          memcpy (x + TEXUV2_POINTER, gc->pipe[i].array.texuv2, TEX_SIZE);
+        if (gc->pipe[i].array.use_texuv3)
+          memcpy (x + TEXUV3_POINTER, gc->pipe[i].array.texuv3, TEX_SIZE);
+        if (gc->pipe[i].array.use_texm)
+          memcpy (x + TEXM_POINTER, gc->pipe[i].array.texm, TEX_SIZE);
+        glUnmapBuffer(GL_ARRAY_BUFFER);
+#else
+# define VERTEX_POINTER gc->pipe[i].array.vertex
+# define COLOR_POINTER gc->pipe[i].array.color
+# define TEXUV_POINTER gc->pipe[i].array.texuv
+# define TEXUV2_POINTER gc->pipe[i].array.texuv2
+# define TEXUV3_POINTER gc->pipe[i].array.texuv3
+# define TEXM_POINTER gc->pipe[i].array.texm
+#endif
+        glVertexAttribPointer(SHAD_VERTEX, 3, GL_SHORT, GL_FALSE, 0, VERTEX_POINTER);
         GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-        glVertexAttribPointer(SHAD_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, gc->pipe[i].array.color);
+        glVertexAttribPointer(SHAD_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, COLOR_POINTER);
         GLERR(__FUNCTION__, __FILE__, __LINE__, "");
         if (gc->pipe[i].array.use_texuv)
           {
              glEnableVertexAttribArray(SHAD_TEXUV);
              GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-             glVertexAttribPointer(SHAD_TEXUV, 2, GL_FLOAT, GL_FALSE, 0, gc->pipe[i].array.texuv);
+             glVertexAttribPointer(SHAD_TEXUV, 2, GL_FLOAT, GL_FALSE, 0, TEXUV_POINTER);
              GLERR(__FUNCTION__, __FILE__, __LINE__, "");
           }
         else
@@ -2572,7 +2641,7 @@
 	       {
 		  glEnableVertexAttribArray(SHAD_TEXM);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-                  glVertexAttribPointer(SHAD_TEXM, 2, GL_FLOAT, GL_FALSE, 0, gc->pipe[i].array.texm);
+                  glVertexAttribPointer(SHAD_TEXM, 2, GL_FLOAT, GL_FALSE, 0, TEXM_POINTER);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
                   glActiveTexture(GL_TEXTURE1);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
@@ -2591,9 +2660,9 @@
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
                   glEnableVertexAttribArray(SHAD_TEXUV3);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-                  glVertexAttribPointer(SHAD_TEXUV2, 2, GL_FLOAT, GL_FALSE, 0, gc->pipe[i].array.texuv2);
+                  glVertexAttribPointer(SHAD_TEXUV2, 2, GL_FLOAT, GL_FALSE, 0, TEXUV2_POINTER);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-                  glVertexAttribPointer(SHAD_TEXUV3, 2, GL_FLOAT, GL_FALSE, 0, gc->pipe[i].array.texuv3);
+                  glVertexAttribPointer(SHAD_TEXUV3, 2, GL_FLOAT, GL_FALSE, 0, TEXUV3_POINTER);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
 
                   glActiveTexture(GL_TEXTURE1);
@@ -2620,7 +2689,7 @@
                {
                   glEnableVertexAttribArray(SHAD_TEXUV2);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
-                  glVertexAttribPointer(SHAD_TEXUV2, 2, GL_FLOAT, GL_FALSE, 0, gc->pipe[i].array.texuv2);
+                  glVertexAttribPointer(SHAD_TEXUV2, 2, GL_FLOAT, GL_FALSE, 0, TEXUV2_POINTER);
                   GLERR(__FUNCTION__, __FILE__, __LINE__, "");
 
                   glActiveTexture(GL_TEXTURE1);
@@ -2698,6 +2767,10 @@
         gc->pipe[i].array.num = 0;
         gc->pipe[i].array.alloc = 0;
 
+#ifdef GL_USE_SERVER_BUFFERS
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+#endif
+
         gc->pipe[i].region.x = 0;
         gc->pipe[i].region.y = 0;
         gc->pipe[i].region.w = 0;
diff -burN evas-1.7.9/src/modules/engines/gl_psl1ght/evas_engine.c evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/evas_engine.c
--- evas-1.7.9/src/modules/engines/gl_psl1ght/evas_engine.c	1969-12-31 19:00:00.000000000 -0500
+++ evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/evas_engine.c	2014-07-03 17:58:24.305177571 -0400
@@ -0,0 +1,1276 @@
+
+#include "config.h"
+
+#include "evas_common.h"
+#include "evas_private.h"
+#include "evas_gl_common.h"
+#include "evas_engine.h"
+#include "Evas.h"
+#include "Evas_Engine_GL_PSL1GHT.h"
+
+#include <malloc.h>
+#include <EGL/egl.h>
+#include <sysutil/video.h>
+
+int _evas_engine_gl_psl1ght_log_dom = -1;
+
+/* function tables - filled in later (func and parent func) */
+static Evas_Func func, pfunc;
+
+/* engine struct data */
+typedef struct _Render_Engine Render_Engine;
+
+static int eng_image_alpha_get(void *data __UNUSED__, void *image);
+static int eng_image_colorspace_get(void *data __UNUSED__, void *image);
+
+#define MAX_BUFFERS 2
+
+struct _Render_Engine
+{
+   Evas_Engine_Info_GL_PSL1GHT	*info;
+   int			w, h;
+
+   Evas_Engine_GL_Context *gl_context;
+   Tilebuf        *tb;
+   struct {
+      int              redraw : 1;
+      int              drew : 1;
+      int              x1, y1, x2, y2;
+   } draw;
+
+
+   EGLContext       egl_context[1];
+   EGLSurface       egl_surface[1];
+   EGLConfig        egl_config;
+   EGLDisplay       egl_disp;
+
+   int             end : 1;
+};
+
+void gl_debug(GLsizei n,const GLchar * s)
+{
+  printf("%s", s);
+}
+
+static u8
+getPreferredResolution(u16 width, u16 height)
+{
+   videoDeviceInfo info;
+   videoResolution res;
+   int area = width * height;
+   int mode_area;
+   int min_area_diff = abs (area - (720 * 480));
+   int area_diff;
+   u8 resolution = VIDEO_RESOLUTION_480;
+   int i;
+
+   videoGetDeviceInfo(0, 0, &info);
+
+   for (i = 0; i < info.availableModeCount; i++) {
+        videoGetResolution (info.availableModes[i].resolution, &res);
+        mode_area = res.width * res.height;
+        area_diff = abs (area - mode_area);
+        if (area_diff < min_area_diff)
+          {
+             min_area_diff = area_diff;
+             resolution = info.availableModes[i].resolution;
+          }
+     }
+
+   return resolution;
+}
+
+static int
+setResolution(u16 *width, u16 *height)
+{
+   videoState state;
+   videoConfiguration vconfig;
+   videoResolution res;
+   u8 resolution;
+
+   resolution = getPreferredResolution (*width, *height);
+
+   /* Get the state of the display */
+   if (videoGetState (0, 0, &state) != 0)
+     return FALSE;
+
+   /* Make sure display is enabled */
+   if (state.state != 0)
+     return FALSE;
+
+   if (videoGetResolution (resolution, &res) != 0)
+     return FALSE;
+
+   /* Configure the buffer format to xRGB */
+   memset (&vconfig, 0, sizeof(videoConfiguration));
+   vconfig.resolution = resolution;
+   vconfig.format = VIDEO_BUFFER_FORMAT_XRGB;
+   vconfig.pitch = res.width * sizeof(u32);
+   vconfig.aspect = VIDEO_ASPECT_AUTO;
+
+   if (videoConfigure (0, &vconfig, NULL, 0) != 0)
+     return FALSE;
+
+   *width = res.width;
+   *height = res.height;
+
+   return TRUE;
+}
+
+/* internal engine routines */
+static void *
+_output_setup(int w, int h)
+{
+   Render_Engine *re;
+   EGLint version0 = 0,version1 = 0;
+   EGLBoolean result;
+   EGLint attribs[] = {
+     EGL_RED_SIZE,8,
+     EGL_BLUE_SIZE,8,
+     EGL_GREEN_SIZE,8,
+     EGL_ALPHA_SIZE,8,
+     EGL_DEPTH_SIZE,16,
+     EGL_NONE
+   };
+   EGLConfig config;
+   EGLint nconfig = 0;
+   u16 width, height;
+
+   printf ("_output_setup called : %dx%d\n", w, h);
+   re = calloc(1, sizeof(Render_Engine));
+   if (!re)
+     return NULL;
+
+   glInitDebug(1024*256, gl_debug);
+
+   width = w;
+   height = h;
+   setResolution (&width, &height);
+   printf ("Resolution changed to : %dx%d\n", width, height);
+
+   /* Setup EGL display and config */
+   re->egl_disp = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+   if (re->egl_disp == EGL_NO_DISPLAY)
+     {
+	free(re);
+	return NULL;
+     }
+
+   result = eglInitialize(re->egl_disp, &version0, &version1);
+   if (!result)
+     {
+	eglTerminate(re->egl_disp);
+	free(re);
+	return NULL;
+     }
+
+   result = eglChooseConfig(re->egl_disp, attribs, &re->egl_config, 1, &nconfig);
+   if (nconfig == 0)
+     {
+	eglTerminate(re->egl_disp);
+	free(re);
+	return NULL;
+     }
+
+   re->egl_surface[0] = eglCreateWindowSurface(re->egl_disp, re->egl_config, 0, 0);
+   if (re->egl_surface[0] == EGL_NO_SURFACE)
+     {
+	eglTerminate(re->egl_disp);
+	free(re);
+	return NULL;
+     }
+
+
+   re->egl_context[0] = eglCreateContext(re->egl_disp, re->egl_config, 0, 0);
+   if (re->egl_context[0] == EGL_NO_CONTEXT)
+     {
+	eglTerminate(re->egl_disp);
+	free(re);
+	return NULL;
+     }
+
+   result = eglMakeCurrent(re->egl_disp, re->egl_surface[0], re->egl_surface[0], re->egl_context[0]);
+   if (!result)
+     {
+	eglDestroyContext(re->egl_disp, re->egl_context[0]);
+	eglTerminate(re->egl_disp);
+	free(re);
+	return NULL;
+     }
+
+   eglQuerySurface(re->egl_disp, re->egl_surface[0], EGL_WIDTH, &re->w);
+   eglQuerySurface(re->egl_disp, re->egl_surface[0], EGL_HEIGHT, &re->h);
+
+   printf ("Created EGL surface : %dx%d\n", re->w, re->h);
+
+   /* Setup GL context */
+   re->gl_context = evas_gl_common_context_new();
+   if (!re->gl_context)
+     {
+	free(re);
+	return NULL;
+     }
+   evas_gl_common_context_use(re->gl_context);
+   evas_gl_common_context_resize(re->gl_context, re->w, re->h, re->gl_context->rot);
+
+   /* if we haven't initialized - init (automatic abort if already done) */
+   evas_common_cpu_init();
+   evas_common_blend_init();
+   evas_common_image_init();
+   evas_common_convert_init();
+   evas_common_scale_init();
+   evas_common_rectangle_init();
+   evas_common_polygon_init();
+   evas_common_line_init();
+   evas_common_font_init();
+   evas_common_draw_init();
+   evas_common_tilebuf_init();
+
+   re->tb = evas_common_tilebuf_new(re->w, re->h);
+
+   /* in preliminary tests 16x16 gave highest framerates */
+   evas_common_tilebuf_set_tile_size(re->tb, TILESIZE, TILESIZE);
+
+   return re;
+}
+
+/* engine api this module provides */
+static void *
+eng_info(Evas *e)
+{
+   Evas_Engine_Info_GL_PSL1GHT *info;
+
+   printf ("eng_info called\n");
+   info = calloc(1, sizeof(Evas_Engine_Info_GL_PSL1GHT));
+   if (!info)
+     return NULL;
+
+   info->magic.magic = rand();
+   info->render_mode = EVAS_RENDER_MODE_BLOCKING;
+
+   return info;
+}
+
+static void
+eng_info_free(Evas *e __UNUSED__, void *info)
+{
+   Evas_Engine_Info_GL_PSL1GHT *in;
+
+   printf ("eng_info_free called\n");
+   in = (Evas_Engine_Info_GL_PSL1GHT *)info;
+   free(in);
+}
+
+static int
+eng_setup(Evas *e, void *in)
+{
+   Evas_Engine_Info_GL_PSL1GHT *info;
+
+   printf ("eng_setup called\n");
+   info = (Evas_Engine_Info_GL_PSL1GHT *)in;
+
+   e->engine.data.output = _output_setup(e->output.w, e->output.h);
+   if (!e->engine.data.output)
+     return 0;
+
+   e->engine.func = &func;
+   e->engine.data.context = e->engine.func->context_new(e->engine.data.output);
+
+   return 1;
+}
+
+static Eina_Bool
+eng_canvas_alpha_get(void *data, void *context __UNUSED__)
+{
+   return EINA_TRUE;
+}
+
+static void
+eng_output_free(void *data)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+
+
+   if (re)
+     {
+       evas_gl_common_context_free(re->gl_context);
+       eglMakeCurrent(re->egl_disp, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+       eglDestroySurface(re->egl_disp, re->egl_surface[0]);
+       eglDestroyContext(re->egl_disp, re->egl_context[0]);
+       eglTerminate(re->egl_disp);
+       free(re);
+
+       evas_common_font_shutdown();
+       evas_common_image_shutdown();
+
+     }
+}
+
+static void
+eng_output_resize(void *data, int w, int h)
+{
+   Render_Engine *re;
+   u16 width, height;
+
+   printf ("eng_output_resize called : %dx%d\n", w, h);
+   re = (Render_Engine *)data;
+
+   /* FIXME: do we need to swap buffers to make sure the rsx is inactive? */
+   eglSwapBuffers(re->egl_disp, re->egl_surface[0]);
+
+   width = w;
+   height = h;
+   setResolution (&width, &height);
+   printf ("Resolution changed to : %dx%d\n", width, height);
+
+   eglQuerySurface(re->egl_disp, re->egl_surface[0], EGL_WIDTH, &re->w);
+   eglQuerySurface(re->egl_disp, re->egl_surface[0], EGL_HEIGHT, &re->h);
+   printf ("EGL surface size is : %dx%d\n", re->w, re->h);
+
+   evas_gl_common_context_resize(re->gl_context, re->w, re->h, re->gl_context->rot);
+   evas_common_tilebuf_free(re->tb);
+   re->tb = evas_common_tilebuf_new(re->w, re->h);
+   if (re->tb)
+     evas_common_tilebuf_set_tile_size(re->tb, TILESIZE, TILESIZE);
+}
+
+static void
+eng_output_tile_size_set(void *data, int w, int h)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_common_tilebuf_set_tile_size(re->tb, w, h);
+}
+
+static void
+eng_output_redraws_rect_add(void *data, int x, int y, int w, int h)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_gl_common_context_resize(re->gl_context, re->w, re->h, re->gl_context->rot);
+   evas_common_tilebuf_add_redraw(re->tb, x, y, w, h);
+
+   RECTS_CLIP_TO_RECT(x, y, w, h, 0, 0, re->w, re->h);
+   if ((w <= 0) || (h <= 0)) return;
+   if (!re->draw.redraw)
+     {
+#if 1
+	re->draw.x1 = x;
+	re->draw.y1 = y;
+	re->draw.x2 = x + w - 1;
+	re->draw.y2 = y + h - 1;
+#else
+	re->draw.x1 = 0;
+	re->draw.y1 = 0;
+	re->draw.x2 = re->w - 1;
+	re->draw.y2 = re->h - 1;
+#endif
+     }
+   else
+     {
+	if (x < re->draw.x1) re->draw.x1 = x;
+	if (y < re->draw.y1) re->draw.y1 = y;
+	if ((x + w - 1) > re->draw.x2) re->draw.x2 = x + w - 1;
+	if ((y + h - 1) > re->draw.y2) re->draw.y2 = y + h - 1;
+     }
+   re->draw.redraw = 1;
+}
+
+static void
+eng_output_redraws_rect_del(void *data, int x, int y, int w, int h)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_common_tilebuf_del_redraw(re->tb, x, y, w, h);
+}
+
+static void
+eng_output_redraws_clear(void *data)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_common_tilebuf_clear(re->tb);
+}
+
+static void *
+eng_output_redraws_next_update_get(void *data, int *x, int *y, int *w, int *h, int *cx, int *cy, int *cw, int *ch)
+{
+   Render_Engine *re;
+   Tilebuf_Rect *rects;
+
+   re = (Render_Engine *)data;
+   /* get the upate rect surface - return engine data as dummy */
+   rects = evas_common_tilebuf_get_render_rects(re->tb);
+   if (rects)
+     {
+        evas_common_tilebuf_free_render_rects(rects);
+        evas_common_tilebuf_clear(re->tb);
+        evas_gl_common_context_flush(re->gl_context);
+        evas_gl_common_context_newframe(re->gl_context);
+        if (x) *x = 0;
+        if (y) *y = 0;
+        if (w) *w = re->w;
+        if (h) *h = re->h;
+        if (cx) *cx = 0;
+        if (cy) *cy = 0;
+        if (cw) *cw = re->w;
+        if (ch) *ch = re->h;
+        return re->gl_context->def_surface;
+     }
+   return NULL;
+}
+
+static void
+eng_output_redraws_next_update_push(void *data, void *surface, int x, int y, int w, int h)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   /* put back update surface.. in this case just unflag redraw */
+   re->draw.redraw = 0;
+   re->draw.drew = 1;
+   evas_gl_common_context_flush(re->gl_context);
+}
+
+static void
+eng_context_cutout_add(void *data __UNUSED__, void *context, int x, int y, int w, int h)
+{
+   evas_common_draw_context_add_cutout(context, x, y, w, h);
+}
+
+static void
+eng_context_cutout_clear(void *data __UNUSED__, void *context)
+{
+   evas_common_draw_context_clear_cutouts(context);
+}
+
+static void
+eng_output_flush(void *data)
+{
+   Render_Engine *re;
+   EGLBoolean result;
+
+   re = (Render_Engine *)data;
+   if (!re->draw.drew) return;
+   re->draw.drew = 0;
+
+   result = eglSwapBuffers(re->egl_disp, re->egl_surface[0]);
+
+   if(!result)
+     printf("Swap sync timed-out: %x\n", eglGetError ());
+}
+
+static void
+eng_output_idle_flush(void *data)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+}
+
+static void
+eng_output_dump(void *data)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_common_image_image_all_unload();
+   evas_common_font_font_all_unload();
+   evas_gl_common_image_all_unload(re->gl_context);
+}
+
+static void
+eng_rectangle_draw(void *data, void *context, void *surface, int x, int y, int w, int h)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+   evas_gl_common_rect_draw(re->gl_context, x, y, w, h);
+}
+
+static void
+eng_line_draw(void *data, void *context, void *surface, int x1, int y1, int x2, int y2)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+   evas_gl_common_line_draw(re->gl_context, x1, y1, x2, y2);
+}
+
+static void *
+eng_polygon_point_add(void *data, void *context __UNUSED__, void *polygon, int x, int y)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   return evas_gl_common_poly_point_add(polygon, x, y);
+}
+
+static void *
+eng_polygon_points_clear(void *data, void *context __UNUSED__, void *polygon)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   return evas_gl_common_poly_points_clear(polygon);
+}
+
+static void
+eng_polygon_draw(void *data, void *context, void *surface, void *polygon, int x, int y)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+   evas_gl_common_poly_draw(re->gl_context, polygon, x, y);
+}
+
+static void *
+eng_image_load(void *data, const char *file, const char *key, int *error, Evas_Image_Load_Opts *lo)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   *error = EVAS_LOAD_ERROR_NONE;
+   return evas_gl_common_image_load(re->gl_context, file, key, lo, error);
+}
+
+static void *
+eng_image_new_from_data(void *data, int w, int h, DATA32 *image_data, int alpha, int cspace)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   return evas_gl_common_image_new_from_data(re->gl_context, w, h, image_data, alpha, cspace);
+}
+
+static void *
+eng_image_new_from_copied_data(void *data, int w, int h, DATA32 *image_data, int alpha, int cspace)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   return evas_gl_common_image_new_from_copied_data(re->gl_context, w, h, image_data, alpha, cspace);
+}
+
+static void
+eng_image_free(void *data, void *image)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   if (!image) return;
+   evas_gl_common_image_free(image);
+}
+
+static void
+eng_image_size_get(void *data __UNUSED__, void *image, int *w, int *h)
+{
+   if (!image)
+     {
+        *w = 0;
+        *h = 0;
+        return;
+     }
+   if (w) *w = ((Evas_GL_Image *)image)->w;
+   if (h) *h = ((Evas_GL_Image *)image)->h;
+}
+
+static void *
+eng_image_size_set(void *data, void *image, int w, int h)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im = image;
+   Evas_GL_Image *im_old;
+
+   re = (Render_Engine *)data;
+   if (!im) return NULL;
+   if (im->native.data)
+     {
+        im->w = w;
+        im->h = h;
+        return image;
+     }
+
+   if ((im->tex) && (im->tex->pt->dyn.img))
+     {
+        evas_gl_common_texture_free(im->tex);
+        im->tex = NULL;
+        im->w = w;
+        im->h = h;
+        im->tex = evas_gl_common_texture_dynamic_new(im->gc, im);
+        return image;
+     }
+   im_old = image;
+
+   switch (eng_image_colorspace_get(data, image))
+     {
+      case EVAS_COLORSPACE_YCBCR422P601_PL:
+      case EVAS_COLORSPACE_YCBCR422P709_PL:
+      case EVAS_COLORSPACE_YCBCR422601_PL:
+      case EVAS_COLORSPACE_YCBCR420NV12601_PL:
+      case EVAS_COLORSPACE_YCBCR420TM12601_PL:
+         w &= ~0x1;
+         break;
+     }
+
+   if ((im_old) &&
+       ((int)im_old->im->cache_entry.w == w) &&
+       ((int)im_old->im->cache_entry.h == h))
+     return image;
+   if (im_old)
+     {
+        im = evas_gl_common_image_new(re->gl_context, w, h,
+                                      eng_image_alpha_get(data, image),
+                                      eng_image_colorspace_get(data, image));
+        evas_gl_common_image_free(im_old);
+     }
+   else
+     im = evas_gl_common_image_new(re->gl_context, w, h, 1, EVAS_COLORSPACE_ARGB8888);
+   return im;
+}
+
+static void *
+eng_image_dirty_region(void *data, void *image, int x, int y, int w, int h)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im = image;
+
+   re = (Render_Engine *)data;
+   if (!image) return NULL;
+   if (im->native.data) return image;
+   evas_gl_common_image_dirty(image, x, y, w, h);
+   return image;
+}
+
+static void *
+eng_image_data_get(void *data, void *image, int to_write, DATA32 **image_data, int *err)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im;
+   int error;
+
+   re = (Render_Engine *)data;
+   if (!image)
+     {
+        *image_data = NULL;
+        if (err) *err = EVAS_LOAD_ERROR_GENERIC;
+        return NULL;
+     }
+   im = image;
+   if (im->native.data)
+     {
+        *image_data = NULL;
+        if (err) *err = EVAS_LOAD_ERROR_NONE;
+        return im;
+     }
+
+   if ((im->tex) && (im->tex->pt) && (im->tex->pt->dyn.data))
+     {
+        *image_data = im->tex->pt->dyn.data;
+        if (err) *err = EVAS_LOAD_ERROR_NONE;
+        return im;
+     }
+
+   /* Engine can be fail to create texture after cache drop like eng_image_content_hint_set function,
+        so it is need to add code which check im->im's NULL value*/
+
+   if (!im->im)
+    {
+       *image_data = NULL;
+       if (err) *err = EVAS_LOAD_ERROR_RESOURCE_ALLOCATION_FAILED;
+       return NULL;
+    }
+
+   error = evas_cache_image_load_data(&im->im->cache_entry);
+   switch (im->cs.space)
+     {
+      case EVAS_COLORSPACE_ARGB8888:
+         if (to_write)
+           {
+              if (im->references > 1)
+                {
+                   Evas_GL_Image *im_new;
+
+                   im_new = evas_gl_common_image_new_from_copied_data
+                      (im->gc, im->im->cache_entry.w, im->im->cache_entry.h,
+                       im->im->image.data,
+                       eng_image_alpha_get(data, image),
+                       eng_image_colorspace_get(data, image));
+                   if (!im_new)
+                     {
+                        *image_data = NULL;
+                        if (err) *err = EVAS_LOAD_ERROR_RESOURCE_ALLOCATION_FAILED;
+                        return NULL;
+                     }
+                   evas_gl_common_image_free(im);
+                   im = im_new;
+                }
+              else
+                evas_gl_common_image_dirty(im, 0, 0, 0, 0);
+           }
+         *image_data = im->im->image.data;
+         break;
+      case EVAS_COLORSPACE_YCBCR422P601_PL:
+      case EVAS_COLORSPACE_YCBCR422P709_PL:
+      case EVAS_COLORSPACE_YCBCR422601_PL:
+      case EVAS_COLORSPACE_YCBCR420NV12601_PL:
+      case EVAS_COLORSPACE_YCBCR420TM12601_PL:
+         *image_data = im->cs.data;
+         break;
+      default:
+         abort();
+         break;
+     }
+   if (err) *err = error;
+   return im;
+}
+
+static void *
+eng_image_data_put(void *data, void *image, DATA32 *image_data)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im, *im2;
+
+   re = (Render_Engine *)data;
+   if (!image) return NULL;
+   im = image;
+   if (im->native.data) return image;
+   if ((im->tex) && (im->tex->pt)
+       && (im->tex->pt->dyn.data)
+       && (im->cs.space == EVAS_COLORSPACE_ARGB8888))
+     {
+        int w, h;
+
+        if (im->tex->pt->dyn.data == image_data)
+          {
+             if (im->tex->pt->dyn.checked_out > 0)
+               {
+                 im->tex->pt->dyn.checked_out--;
+               }
+
+             return image;
+          }
+
+        w = im->im->cache_entry.w;
+        h = im->im->cache_entry.h;
+        im2 = eng_image_new_from_data(data, w, h, image_data,
+                                      eng_image_alpha_get(data, image),
+                                      eng_image_colorspace_get(data, image));
+        if (!im2) return im;
+        evas_gl_common_image_free(im);
+        im = im2;
+        evas_gl_common_image_dirty(im, 0, 0, 0, 0);
+        return im;
+     }
+   switch (im->cs.space)
+     {
+      case EVAS_COLORSPACE_ARGB8888:
+         if (image_data != im->im->image.data)
+           {
+              int w, h;
+
+              w = im->im->cache_entry.w;
+              h = im->im->cache_entry.h;
+              im2 = eng_image_new_from_data(data, w, h, image_data,
+                                            eng_image_alpha_get(data, image),
+                                            eng_image_colorspace_get(data, image));
+              if (!im2) return im;
+              evas_gl_common_image_free(im);
+              im = im2;
+           }
+         break;
+      case EVAS_COLORSPACE_YCBCR422P601_PL:
+      case EVAS_COLORSPACE_YCBCR422P709_PL:
+      case EVAS_COLORSPACE_YCBCR422601_PL:
+      case EVAS_COLORSPACE_YCBCR420NV12601_PL:
+      case EVAS_COLORSPACE_YCBCR420TM12601_PL:
+         if (image_data != im->cs.data)
+           {
+              if (im->cs.data)
+                {
+                   if (!im->cs.no_free) free(im->cs.data);
+                }
+              im->cs.data = image_data;
+           }
+         evas_gl_common_image_dirty(im, 0, 0, 0, 0);
+         break;
+      default:
+         abort();
+         break;
+     }
+   return im;
+}
+
+static void
+eng_image_data_preload_request(void *data __UNUSED__, void *image, const void *target)
+{
+   Evas_GL_Image *gim = image;
+   RGBA_Image *im;
+
+   if (!gim) return;
+   if (gim->native.data) return;
+   im = (RGBA_Image *)gim->im;
+   if (!im) return;
+   evas_cache_image_preload_data(&im->cache_entry, target);
+}
+
+static void
+eng_image_data_preload_cancel(void *data __UNUSED__, void *image, const void *target)
+{
+   Evas_GL_Image *gim = image;
+   RGBA_Image *im;
+
+   if (!gim) return;
+   if (gim->native.data) return;
+   im = (RGBA_Image *)gim->im;
+   if (!im) return;
+   evas_cache_image_preload_cancel(&im->cache_entry, target);
+}
+
+static void *
+eng_image_alpha_set(void *data, void *image, int has_alpha)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im;
+
+   re = (Render_Engine *)data;
+   if (!image) return NULL;
+   im = image;
+   if (im->alpha == has_alpha) return image;
+   if (im->native.data)
+     {
+        im->alpha = has_alpha;
+        return image;
+     }
+   if ((im->tex) && (im->tex->pt->dyn.img))
+     {
+        im->alpha = has_alpha;
+        im->tex->alpha = im->alpha;
+        return image;
+     }
+   /* FIXME: can move to gl_common */
+   if (im->cs.space != EVAS_COLORSPACE_ARGB8888) return im;
+   if ((has_alpha) && (im->im->cache_entry.flags.alpha)) return image;
+   else if ((!has_alpha) && (!im->im->cache_entry.flags.alpha)) return image;
+   if (im->references > 1)
+     {
+        Evas_GL_Image *im_new;
+
+        im_new = evas_gl_common_image_new_from_copied_data
+           (im->gc, im->im->cache_entry.w, im->im->cache_entry.h,
+               im->im->image.data,
+               eng_image_alpha_get(data, image),
+               eng_image_colorspace_get(data, image));
+        if (!im_new) return im;
+        evas_gl_common_image_free(im);
+        im = im_new;
+     }
+   else
+     evas_gl_common_image_dirty(im, 0, 0, 0, 0);
+   return evas_gl_common_image_alpha_set(im, has_alpha ? 1 : 0);
+}
+
+static int
+eng_image_alpha_get(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *im;
+
+   if (!image) return 1;
+   im = image;
+   return im->alpha;
+}
+
+static void *
+eng_image_border_set(void *data, void *image, int l __UNUSED__, int r __UNUSED__, int t __UNUSED__, int b __UNUSED__)
+{
+   /* even gl_x11 doesn't do anything here */
+   return image;
+}
+
+static void
+eng_image_border_get(void *data, void *image __UNUSED__, int *l __UNUSED__, int *r __UNUSED__, int *t __UNUSED__, int *b __UNUSED__)
+{
+   /* even gl_x11 doesn't do anything here */
+}
+
+static void
+eng_image_draw(void *data, void *context, void *surface, void *image, int src_x, int src_y, int src_w, int src_h, int dst_x, int dst_y, int dst_w, int dst_h, int smooth)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   if (!image) return;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+   evas_gl_common_image_draw(re->gl_context, image,
+                             src_x, src_y, src_w, src_h,
+                             dst_x, dst_y, dst_w, dst_h,
+                             smooth);
+}
+
+static char *
+eng_image_comment_get(void *data, void *image, char *key __UNUSED__)
+{
+   Evas_GL_Image *im;
+
+   if (!image) return NULL;
+   im = image;
+   if (!im->im) return NULL;
+   return im->im->info.comment;
+}
+
+static char *
+eng_image_format_get(void *data, void *image)
+{
+   /* even gl_x11 doesn't do anything here */
+   return NULL;
+}
+
+static void
+eng_image_colorspace_set(void *data, void *image, int cspace)
+{
+   Render_Engine *re;
+   Evas_GL_Image *im;
+
+   re = (Render_Engine *)data;
+   if (!image) return;
+   im = image;
+   if (im->native.data) return;
+   /* FIXME: can move to gl_common */
+   if (im->cs.space == cspace) return;
+   evas_cache_image_colorspace(&im->im->cache_entry, cspace);
+   switch (cspace)
+     {
+      case EVAS_COLORSPACE_ARGB8888:
+	if (im->cs.data)
+	  {
+	     if (!im->cs.no_free) free(im->cs.data);
+	     im->cs.data = NULL;
+	     im->cs.no_free = 0;
+	  }
+	break;
+      case EVAS_COLORSPACE_YCBCR422P601_PL:
+      case EVAS_COLORSPACE_YCBCR422P709_PL:
+      case EVAS_COLORSPACE_YCBCR422601_PL:
+      case EVAS_COLORSPACE_YCBCR420NV12601_PL:
+      case EVAS_COLORSPACE_YCBCR420TM12601_PL:
+        if (im->tex) evas_gl_common_texture_free(im->tex);
+        im->tex = NULL;
+	if (im->cs.data)
+	  {
+	     if (!im->cs.no_free) free(im->cs.data);
+	  }
+	im->cs.data = calloc(1, im->im->cache_entry.h * sizeof(unsigned char *) * 2);
+	im->cs.no_free = 0;
+	break;
+      default:
+	abort();
+	break;
+     }
+   im->cs.space = cspace;
+}
+
+static int
+eng_image_colorspace_get(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *im;
+
+   if (!image) return EVAS_COLORSPACE_ARGB8888;
+   im = image;
+   return im->cs.space;
+}
+
+static Eina_Bool
+eng_image_can_region_get(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *gim = image;
+   Image_Entry *im;
+   if (!gim) return EINA_FALSE;
+   im = (Image_Entry *)gim->im;
+   if (!im) return EINA_FALSE;
+   return ((Evas_Image_Load_Func*) im->info.loader)->do_region;
+}
+
+static void
+eng_image_mask_create(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *im;
+
+   if (!image) return;
+   im = image;
+   if (!im->im->image.data)
+      evas_cache_image_load_data(&im->im->cache_entry);
+   if (!im->tex)
+      im->tex = evas_gl_common_texture_new(im->gc, im->im);
+}
+
+static void *
+eng_image_native_set(void *data, void *image, void *native)
+{
+   /* TODO eventually... doesn't seem to be needed for now though */
+   return NULL;
+}
+
+static void *
+eng_image_native_get(void *data, void *image)
+{
+   /* TODO eventually... doesn't seem to be needed for now though */
+   return NULL;
+}
+
+static void
+eng_font_draw(void *data, void *context, void *surface, Evas_Font_Set *font, int x, int y, int w __UNUSED__, int h __UNUSED__, int ow __UNUSED__, int oh __UNUSED__, Evas_Text_Props *intl_props)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+     {
+        // FIXME: put im into context so we can free it
+	static RGBA_Image *im = NULL;
+
+        if (!im)
+          im = (RGBA_Image *)evas_cache_image_empty(evas_common_image_cache_get());
+        im->cache_entry.w = re->w;
+        im->cache_entry.h = re->h;
+        evas_common_draw_context_font_ext_set(context,
+   					      re->gl_context,
+   					      evas_gl_font_texture_new,
+   					      evas_gl_font_texture_free,
+   					      evas_gl_font_texture_draw);
+	evas_common_font_draw_prepare(intl_props);
+	evas_common_font_draw(im, context, x, y, intl_props);
+	evas_common_draw_context_font_ext_set(context,
+					      NULL,
+					      NULL,
+					      NULL,
+					      NULL);
+     }
+}
+
+static void
+eng_image_scale_hint_set(void *data __UNUSED__, void *image, int hint)
+{
+   if (image) evas_gl_common_image_scale_hint_set(image, hint);
+}
+
+static int
+eng_image_scale_hint_get(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *gim = image;
+   if (!gim) return EVAS_IMAGE_SCALE_HINT_NONE;
+   return gim->scale_hint;
+}
+
+static void
+eng_image_stride_get(void *data __UNUSED__, void *image, int *stride)
+{
+   Evas_GL_Image *im = image;
+
+   if ((im->tex) && (im->tex->pt->dyn.img))
+     *stride = im->tex->pt->dyn.stride;
+   else
+     *stride = im->w * 4;
+}
+
+static void
+eng_image_map_draw(void *data, void *context, void *surface, void *image, RGBA_Map *m, int smooth, int level)
+{
+   Evas_GL_Image *gim = image;
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   if (!image) return;
+   evas_gl_common_context_target_surface_set(re->gl_context, surface);
+   re->gl_context->dc = context;
+   if (m->count != 4)
+     {
+        // FIXME: nash - you didn't fix this
+        abort();
+     }
+   if ((m->pts[0].x == m->pts[3].x) &&
+       (m->pts[1].x == m->pts[2].x) &&
+       (m->pts[0].y == m->pts[1].y) &&
+       (m->pts[3].y == m->pts[2].y) &&
+       (m->pts[0].x <= m->pts[1].x) &&
+       (m->pts[0].y <= m->pts[2].y) &&
+       (m->pts[0].u == 0) &&
+       (m->pts[0].v == 0) &&
+       (m->pts[1].u == (gim->w << FP)) &&
+       (m->pts[1].v == 0) &&
+       (m->pts[2].u == (gim->w << FP)) &&
+       (m->pts[2].v == (gim->h << FP)) &&
+       (m->pts[3].u == 0) &&
+       (m->pts[3].v == (gim->h << FP)) &&
+       (m->pts[0].col == 0xffffffff) &&
+       (m->pts[1].col == 0xffffffff) &&
+       (m->pts[2].col == 0xffffffff) &&
+       (m->pts[3].col == 0xffffffff))
+     {
+        int dx, dy, dw, dh;
+
+        dx = m->pts[0].x >> FP;
+        dy = m->pts[0].y >> FP;
+        dw = (m->pts[2].x >> FP) - dx;
+        dh = (m->pts[2].y >> FP) - dy;
+        eng_image_draw(data, context, surface, image,
+                       0, 0, gim->w, gim->h, dx, dy, dw, dh, smooth);
+     }
+   else
+     {
+        evas_gl_common_image_map_draw(re->gl_context, image, m->count, &m->pts[0],
+                                      smooth, level);
+     }
+}
+
+static void *
+eng_image_map_surface_new(void *data, int w, int h, int alpha)
+{
+   Render_Engine *re;
+
+   re = (Render_Engine *)data;
+   return evas_gl_common_image_surface_new(re->gl_context, w, h, alpha);
+}
+
+static void
+eng_image_map_surface_free(void *data __UNUSED__, void *surface)
+{
+   evas_gl_common_image_free(surface);
+}
+
+static void
+eng_image_map_clean(void *data, RGBA_Map *m)
+{
+}
+
+static int
+eng_image_load_error_get(void *data __UNUSED__, void *image)
+{
+   Evas_GL_Image *im;
+
+   if (!image) return EVAS_LOAD_ERROR_NONE;
+   im = image;
+   return im->im->cache_entry.load_error;
+}
+
+/* module advertising code */
+static int
+module_open(Evas_Module *em)
+{
+   if (!em) return 0;
+   if (!evas_gl_common_module_open()) return 0;
+   /* get whatever engine module we inherit from */
+   if (!_evas_module_engine_inherit(&pfunc, "software_generic")) return 0;
+   _evas_engine_gl_psl1ght_log_dom = eina_log_domain_register
+       ("evas-gl_psl1ght", EVAS_DEFAULT_LOG_COLOR);
+   if (_evas_engine_gl_psl1ght_log_dom < 0)
+     {
+        EINA_LOG_ERR("Can not create a module log domain.");
+        return 0;
+     }
+
+   /* store it for later use */
+   func = pfunc;
+   /* now to override methods */
+#define ORD(f) EVAS_API_OVERRIDE(f, &func, eng_)
+   ORD(info);
+   ORD(info_free);
+   ORD(setup);
+   ORD(canvas_alpha_get);
+   ORD(output_free);
+   ORD(output_resize);
+   ORD(output_tile_size_set);
+   ORD(output_redraws_rect_add);
+   ORD(output_redraws_rect_del);
+   ORD(output_redraws_clear);
+   ORD(output_redraws_next_update_get);
+   ORD(output_redraws_next_update_push);
+   ORD(context_cutout_add);
+   ORD(context_cutout_clear);
+   ORD(output_flush);
+   ORD(output_idle_flush);
+   ORD(output_dump);
+   ORD(rectangle_draw);
+   ORD(line_draw);
+   ORD(polygon_point_add);
+   ORD(polygon_points_clear);
+   ORD(polygon_draw);
+
+   ORD(image_load);
+   ORD(image_new_from_data);
+   ORD(image_new_from_copied_data);
+   ORD(image_free);
+   ORD(image_size_get);
+   ORD(image_size_set);
+   ORD(image_dirty_region);
+   ORD(image_data_get);
+   ORD(image_data_put);
+   ORD(image_data_preload_request);
+   ORD(image_data_preload_cancel);
+   ORD(image_alpha_set);
+   ORD(image_alpha_get);
+   ORD(image_border_set);
+   ORD(image_border_get);
+   ORD(image_draw);
+   ORD(image_comment_get);
+   ORD(image_format_get);
+   ORD(image_colorspace_set);
+   ORD(image_colorspace_get);
+   ORD(image_can_region_get);
+   ORD(image_mask_create);
+   ORD(image_native_set);
+   ORD(image_native_get);
+   ORD(font_draw);
+
+   ORD(image_scale_hint_set);
+   ORD(image_scale_hint_get);
+   ORD(image_stride_get);
+
+   ORD(image_map_draw);
+   ORD(image_map_surface_new);
+   ORD(image_map_surface_free);
+   ORD(image_map_clean);
+
+   ORD(image_load_error_get);
+
+   /* now advertise out own api */
+   em->functions = (void *)(&func);
+   return 1;
+}
+
+static void
+module_close(Evas_Module *em __UNUSED__)
+{
+   eina_log_domain_unregister(_evas_engine_gl_psl1ght_log_dom);
+   evas_gl_common_module_close();
+}
+
+static Evas_Module_Api evas_modapi =
+{
+   EVAS_MODULE_API_VERSION,
+   "gl_psl1ght",
+   "none",
+   {
+      module_open,
+      module_close
+   }
+};
+
+EVAS_MODULE_DEFINE(EVAS_MODULE_TYPE_ENGINE, engine, gl_psl1ght);
+
+#ifndef EVAS_STATIC_BUILD_GL_PSL1GHT
+EVAS_EINA_MODULE_DEFINE(engine, gl_psl1ght);
+#endif
diff -burN evas-1.7.9/src/modules/engines/gl_psl1ght/Evas_Engine_GL_PSL1GHT.h evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/Evas_Engine_GL_PSL1GHT.h
--- evas-1.7.9/src/modules/engines/gl_psl1ght/Evas_Engine_GL_PSL1GHT.h	1969-12-31 19:00:00.000000000 -0500
+++ evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/Evas_Engine_GL_PSL1GHT.h	2014-07-03 17:58:24.305177571 -0400
@@ -0,0 +1,16 @@
+#ifndef _EVAS_ENGINE_GL_PSL1GHT_H
+#define _EVAS_ENGINE_GL_PSL1GHT_H
+
+typedef struct _Evas_Engine_Info_GL_PSL1GHT Evas_Engine_Info_GL_PSL1GHT;
+
+struct _Evas_Engine_Info_GL_PSL1GHT
+{
+   /* PRIVATE - don't mess with this baby or evas will poke its tongue out */
+   /* at you and make nasty noises */
+     Evas_Engine_Info        magic;
+
+     /* non-blocking or blocking mode */
+     Evas_Engine_Render_Mode render_mode;
+};
+#endif
+
diff -burN evas-1.7.9/src/modules/engines/gl_psl1ght/evas_engine.h evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/evas_engine.h
--- evas-1.7.9/src/modules/engines/gl_psl1ght/evas_engine.h	1969-12-31 19:00:00.000000000 -0500
+++ evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/evas_engine.h	2014-07-03 17:58:24.305177571 -0400
@@ -0,0 +1,31 @@
+#ifndef EVAS_ENGINE_H
+#define EVAS_ENGINE_H
+
+
+extern int _evas_engine_gl_psl1ght_log_dom;
+#ifdef ERR
+# undef ERR
+#endif
+#define ERR(...) EINA_LOG_DOM_ERR(_evas_engine_gl_psl1ght_log_dom, __VA_ARGS__)
+
+#ifdef DBG
+# undef DBG
+#endif
+#define DBG(...) EINA_LOG_DOM_DBG(_evas_engine_gl_psl1ght_log_dom, __VA_ARGS__)
+
+#ifdef INF
+# undef INF
+#endif
+#define INF(...) EINA_LOG_DOM_INFO(_evas_engine_gl_psl1ght_log_dom, __VA_ARGS__)
+
+#ifdef WRN
+# undef WRN
+#endif
+#define WRN(...) EINA_LOG_DOM_WARN(_evas_engine_gl_psl1ght_log_dom, __VA_ARGS__)
+
+#ifdef CRIT
+# undef CRIT
+#endif
+#define CRIT(...) EINA_LOG_DOM_CRIT(_evas_engine_gl_psl1ght_log_dom, __VA_ARGS__)
+
+#endif
diff -burN evas-1.7.9/src/modules/engines/gl_psl1ght/Makefile.am evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/Makefile.am
--- evas-1.7.9/src/modules/engines/gl_psl1ght/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ evas-1.7.9-PS3/src/modules/engines/gl_psl1ght/Makefile.am	2014-07-03 17:58:24.306177571 -0400
@@ -0,0 +1,47 @@
+
+MAINTAINERCLEANFILES = Makefile.in
+
+AM_CPPFLAGS = \
+-I. \
+-I$(top_srcdir)/src/lib \
+-I$(top_srcdir)/src/lib/include \
+-I$(top_srcdir)/src/modules/engines \
+-I$(top_srcdir)/src/modules/engines/gl_common \
+@FREETYPE_CFLAGS@ \
+@PIXMAN_CFLAGS@ \
+@EINA_CFLAGS@ \
+@GL_EET_CFLAGS@ \
+@FRIBIDI_CFLAGS@ \
+@evas_engine_gl_psl1ght_cflags@
+
+if BUILD_ENGINE_GL_PSL1GHT
+
+GL_PSL1GHT_SOURCES = \
+evas_engine.c
+
+GL_PSL1GHT_LIBADD = @evas_engine_gl_psl1ght_libs@ $(top_builddir)/src/modules/engines/gl_common/libevas_engine_gl_common.la 
+
+
+includes_HEADERS = Evas_Engine_GL_PSL1GHT.h
+includesdir = $(includedir)/evas-@VMAJ@
+
+if !EVAS_STATIC_BUILD_GL_PSL1GHT
+
+pkgdir = $(libdir)/evas/modules/engines/psl1ght/$(MODULE_ARCH)
+pkg_LTLIBRARIES = module.la
+module_la_SOURCES = $(GL_PSL1GHT_SOURCES)
+module_la_LIBADD = @EINA_LIBS@ $(GL_PSL1GHT_LIBADD) $(top_builddir)/src/lib/libevas.la
+module_la_LDFLAGS = -module -avoid-version
+module_la_LIBTOOLFLAGS = --tag=disable-static
+
+else
+
+noinst_LTLIBRARIES = libevas_engine_gl_psl1ght.la
+
+libevas_engine_gl_psl1ght_la_SOURCES = $(GL_PSL1GHT_SOURCES)
+libevas_engine_gl_psl1ght_la_LIBADD = $(GL_PSL1GHT_LIBADD)
+
+endif
+endif
+
+EXTRA_DIST = evas_engine.h
diff -burN evas-1.7.9/src/modules/engines/Makefile.am evas-1.7.9-PS3/src/modules/engines/Makefile.am
--- evas-1.7.9/src/modules/engines/Makefile.am	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/modules/engines/Makefile.am	2014-07-03 17:58:24.307177571 -0400
@@ -21,6 +21,9 @@
 if !EVAS_STATIC_BUILD_PSL1GHT
 SUBDIRS += psl1ght
 endif
+if !EVAS_STATIC_BUILD_GL_PSL1GHT
+SUBDIRS += gl_psl1ght
+endif
 
 if !EVAS_STATIC_BUILD_GL_COMMON
 SUBDIRS += gl_common
diff -burN evas-1.7.9/src/modules/engines/software_16_sdl/Makefile.am evas-1.7.9-PS3/src/modules/engines/software_16_sdl/Makefile.am
--- evas-1.7.9/src/modules/engines/software_16_sdl/Makefile.am	2013-07-29 10:25:43.000000000 -0400
+++ evas-1.7.9-PS3/src/modules/engines/software_16_sdl/Makefile.am	2014-07-03 17:58:24.308177571 -0400
@@ -2,7 +2,7 @@
 
 MAINTAINERCLEANFILES = Makefile.in
 
-INCLUDES = -I. -I$(top_srcdir)/src/lib -I$(top_srcdir)/src/lib/include \
+AM_CPPFLAGS = -I. -I$(top_srcdir)/src/lib -I$(top_srcdir)/src/lib/include \
 @FREETYPE_CFLAGS@ \
 @PIXMAN_CFLAGS@ \
 @SDL_CFLAGS@ \
